### 第 41 题: JS中this相关问题

1. 
```
var birth = 2000;

var obj1 = {
    birth:1990,
    getAge:function(){
        console.log(this.birth)
    }
}

obj1.getAge(); // 1990
var func = obj1.getAge;
func();        // 2000
```


2. 闭包 + 匿名函数  =>  匿名函数this有全局性, 默认指向window
```
var birth = 2000;

var obj1 = {
    birth:1990,
    getAge:function(){
        let fn = function(){
            console.log(this.birth)
        }
        return fn();
    }
}

obj1.getAge(); // 2000
var func = obj1.getAge;
func();        // 2000

```

3. 闭包 + 匿名函数 + (that = this)
```
var birth = 2000;

var obj1 = {
    birth:1990,
    getAge:function(){
        let that = this;
        let fn = function(){
            console.log(that.birth)
        }
        return fn();
    }
}

obj1.getAge(); // 1990
var func = obj1.getAge;
func();        // 2000

```

4. 闭包 + 箭头函数
```
var birth = 2000;

var obj1 = {
    birth:1990,
    getAge:function(){
        let fn = ()=>
            console.log(this.birth)
        return fn();
    }
}

obj1.getAge(); // 1990
var func = obj1.getAge;
func();        // 2000

```


### 第 42 题: GET 和 POST 的区别

1. Get请求的参数放在URL里，Post请求的参数放在实体里。
2. Get请求比起Post请求更加不安全，因为参数放在URL中，不能用来传递敏感信息。
3. Get请求的参数放在URL中，所以有长度限制；而Post请求没有限制。


### 第 43 题: 手动实现 bind / call / apply 方法

#### bind ####

```
Function.prototype.myBind = function (context, ...args) {
    return (...newArgs) => {
        return this.call(context, ...args, ...newArgs)
    }
}
```


#### call ####

先看一个例子
```
var foo = {
    value: 1
};

function bar() {
    console.log(this.value);
}

bar.call(foo); // 1
```
注意到call函数改变了bar中this的指向, 然后执行了bar函数, 我们可以把例子转换成这样
```
var foo = {
    value: 1,
    bar: function() {
        console.log(this.value)
    }
};

foo.bar(); // 1
```
但此时我们给foo多增加了一个bar属性, 因此我们要后续删除掉该属性, 于是第一版代码如下
```
Function.prototype.myCall = function(context){

    context.fn = this;
    context.fn();
    delete context.fn;
}
```

***

接下来我们要考虑输入参数的情况
```
Function.prototype.myCall = function(context) {
    context.fn = this;
    var args = [];

    for(var i = 1, len = arguments.length; i < len; i++) {
        args.push('arguments[' + i + ']');
    }
    eval('context.fn(' + args +')');
    delete context.fn;
}

```

***

最后再稍作修改, 如果this传值为null, 那么我们就令其指向window
```
Function.prototype.myCall = function(context) {
    var context = context || window;
    context.fn = this;

    var args = [];
    for(var i = 1, len = arguments.length; i < len; i++) {
        args.push('arguments[' + i + ']');
    }

    var result = eval('context.fn(' + args +')');

    delete context.fn
    return result;
}

// 简化版

Function.prototype.myCall = function (context, ...args) {
    // context为null时，context设置为window
    context = context || window
    context.fn = this
    let result = context.fn(...args)
    delete context.fn
    return result
}

// 测试一下
var value = 2;

var obj = {
    value: 1
}

function bar(name, age) {
    console.log(this.value);
    return {
        value: this.value,
        name: name,
        age: age
    }
}

bar.myCall(null); // 2

console.log(bar.myCall(obj, 'kevin', 18));

// 1
// Object {
//    value: 1,
//    name: 'kevin',
//    age: 18
// }

```



#### apply ####

和call类似, 注意一下参数部分就好了
```
Function.prototype.myApply = function (context, args) {
    context = context || window
    context.fn = this
    let result = context.fn(...args)
    delete context.fn
    return result
}
```