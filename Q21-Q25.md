### 第 21 题：为什么for循环嵌套顺序会影响性能？
```
var t1 = new Date().getTime()
for (let i = 0; i < 100; i++) {
  for (let j = 0; j < 1000; j++) {
    for (let k = 0; k < 10000; k++) {
    }
  }
}
var t2 = new Date().getTime()
console.log('first time', t2 - t1)

for (let i = 0; i < 10000; i++) {
  for (let j = 0; j < 1000; j++) {
    for (let k = 0; k < 100; k++) {

    }
  }
}
var t3 = new Date().getTime()
console.log('two time', t3 - t2)  
```

两个循环的次数的是一样的，但是 j 与 k 的初始化次数是不一样的
- 第一个循环的 j 的初始化次数是 100 次，k 的初始化次数是 10w 次
- 第二个循环的 j 的初始化次数是 1w 次， k 的初始化次数是 1000w 次
所以相同循环次数，外层越大，越影响性能. 可能的话将循环次数少的放在外层，减少内层变量的操作(初始化，比较，自增等)次数


### 第 22 题：输出下列代码运行结果
```
1 + "1"

2 * "2"

[1, 2] + [2, 1]

"a" + + "b"
```

答案是 "11"  "4"  "1,22,1"  "aNaN"<br/>
第三个是因为Javascript中所有对象基本都是先调用valueOf方法，如果不是数值，再调用toString方法. 所以两个数组对象的toString方法相加，值为："1,22,1" <br/>
第四个后边的"+"将作为一元操作符，如果操作数是字符串，将调用Number方法将该操作数转为数值，如果操作数无法转为数值，则为NaN. 因此结果是"aNaN"


### 第 23 题：匿名函数和箭头函数
```
var obj1 = {
    birth: 1990,
    getAge: function (year) {   
        let fn=function(y){
            return y - this.birth; // this指向window或undefined
        };  
        return fn(year); 
    }
};

var obj2 = {
    birth: 1990,
    getAge: function (year) {
        var fn = (y) => y - this.birth; // this.birth为1990
        return fn(year);
    }
};
```
和带名函数相比，匿名函数需要讲地址赋值给另一个变量let a，然后再用a来调用函数；和匿名函数比，箭头函数完全修复了this的指向，this总是指向词法作用域<br/>
[箭头函数与普通函数（function）的区别是什么？构造函数（function）可以使用 new 生成实例，那么箭头函数可以吗？为什么？](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/101)

### 第 24 题：前端状态码
[状态码](https://www.daqianduan.com/4280.html)


### 第 25 题：跨域问题及解决方案
[9种常见的前端跨域解决方案（详解）](https://www.imooc.com/article/291931)

  1. **JSONP**:

  依靠<script>标签它本身没有跨域限制, 在src属性中指定目标URL/参数/callback函数, 服务端拿到数据和请求后将结果拼凑到callback函数中返回给前端, 前端再执行callback函数的内容

  缺点是一般只可用于GET请求
```  
  script.src = 'http://www.domain2.com:8080/login?user=admin&callback=handleCallback';
```
 
  2. **cors**:

  后端部分书写诸如Access-Control-Allow-Origin的字段，来允许来自部分域名的请求
  
  3. **nginx**:

  **注意到同源策略仅是针对浏览器的安全策略。服务器端调用HTTP接口只是使用HTTP协议，不需要同源策略，也就不存在跨域问题。** 
  
  这里的解决思路是使用nginx创建一个服务器进行反向代理。例如我们前端的地址是localhost:8000, 原本server的地址是localhost:1000, 我们无法从前端直接访问server部分的数据(域名相同 端口不同 产生跨域). 我们可以设置一个代理服务器 localhost:8000/api, 当我们需要后端数据的时候, localhost:8000 ---(请求)---> localhost:8000/api ---(请求)---> localhost:1000
  
  4. **node.js中间件**:
  
  例如我毕设里就直接使用了 app.use(require('cors')())
  
  5. **document.domain + iframe 跨域**:
  
  当两个窗口主域相同, 只有子域不同的时候, 可以通过document.domain强行设置主域相同, 以此允许二者之间的访问.
  
  6. **location.hash + iframe 跨域**:
  
  注意在url： http://a.com#helloword 中的'#helloworld'就是location.hash
  
  7. **window.name + iframe 跨域**

  8. **postMessage 跨域**

  9. **WebSocket 跨域协议**
