### 第 16 题：改造下面的代码，使之输出0 - 9，写出你能想到的所有解法 ?
```
for (var i = 0; i< 10; i++){
	setTimeout(() => {
		console.log(i);
    }, 1000)
}
```
首先我们得知道它的输出是9,9,9....,9(作用域问题)
+ 方法一
原理
- 利用 setTimeout 函数的第三个参数，会作为回调函数的第一个参数传入
- 利用 bind 函数部分执行的特性
代码1:
```
for (var i = 0; i < 10; i++) {
  setTimeout(i => {
    console.log(i);
  }, 1000, i)
}
```
代码2:
```
for (var i = 0; i < 10; i++) {
  setTimeout(console.log.bind(Object.create(null), i), 1000)
}
```

+ 方法二
原理:
- 利用 let 变量的特性 — 在每一次 for 循环的过程中，let 声明的变量会在当前的块级作用域里面（for 循环的 body 体，也即两个花括号之间的内容区域）创建一个文法环境（Lexical Environment），该环境里面包括了当前 for 循环过程中的 i
代码1:
```
for (let i = 0; i < 10; i++) {
  setTimeout(() => {
    console.log(i);
  }, 1000)
}
```


### 第 17 题：使用 JSON.stringify 进行深拷贝的缺点 ?

1. 如果obj里面有时间对象，则JSON.stringify后再JSON.parse的结果，时间将只是字符串的形式，而不是对象的形式
2. 如果obj里有 RegExp (正则表达式的缩写)、Error 对象，则序列化的结果将只得到空对象
3. 如果obj里有函数，undefined，则序列化的结果会把函数或 undefined丢失
4. 如果obj里有NaN、Infinity和-Infinity，则序列化的结果会变成null
5. JSON.stringify() 只能序列化对象的可枚举的自有属性，例如如果 obj 中的对象是有构造函数生成的， 则使用 JSON.parse(JSON.stringify(obj)) 深拷贝后，会丢弃对象的 constructor
6. 如果对象中存在循环引用的情况也无法正确实现深拷贝

作为总结: JSON.parse(JSON.stringfy(X))，其中X只能是Number, String, Boolean, Array, 扁平对象，即那些能够被 JSON 直接表示的数据结构
