**2021/01/01**
*Happy New Year*

---


### 第 1 题：什么是防抖和节流？有什么区别？如何实现？

1. 防抖<br/>
>触发高频事件后n秒内函数只会执行一次，如果n秒内高频事件再次被触发，则重新计算时间
```
function debounce(fn) {
      let timeout = null; // 创建一个标记用来存放定时器的返回值
      return function () {
        clearTimeout(timeout); // 每当用户输入的时候把前一个 setTimeout clear 掉
        timeout = setTimeout(() => { // 然后又创建一个新的 setTimeout, 这样就能保证输入字符后的 interval 间隔内如果还有字符输入的话，就不会执行 fn 函数
          fn.apply(this, arguments);
        }, 500);
      };
    }
    function sayHi() {
      console.log('防抖成功');
    }

    var inp = document.getElementById('inp');
    inp.addEventListener('input', debounce(sayHi)); // 防抖

```
[JavaScript专题之跟着underscore学防抖](https://github.com/mqyqingfeng/Blog/issues/22)

2. 节流<br/>
>高频事件触发，但在n秒内只会执行一次，所以节流会稀释函数的执行频率
```
function throttle(fn) {
      let canRun = true; // 通过闭包保存一个标记
      return function () {
        if (!canRun) return; // 在函数开头判断标记是否为true，不为true则return
        canRun = false; // 立即设置为false
        setTimeout(() => { // 将外部传入的函数的执行放在setTimeout中
          fn.apply(this, arguments);
          // 最后在setTimeout执行完毕后再把标记设置为true(关键)表示可以执行下一次循环了。当定时器没有执行的时候标记永远是false，在开头被return掉
          canRun = true;
        }, 500);
      };
    }
    function sayHi(e) {
      console.log(e.target.innerWidth, e.target.innerHeight);
    }
    window.addEventListener('resize', throttle(sayHi));

```
[JavaScript专题之跟着 underscore 学节流](https://github.com/mqyqingfeng/Blog/issues/26)


<br/>


### 第 2 题：Set Map WeakSet WeakMap的关联与区别？

1. Set<br/>
> 1. 成员不能重复 => 基于此可以有一个巧妙地数组去重方法
> 2. 只有健值,没有健名,有点类似数组
> 3. 可以遍历,方法有add,delete,has

2. WeakSet<br/>
> 1. WeakSet 的成员只能是对象，而不能是其他类型的值
> 2. WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中

3. Map<br/>
> 1. 本质上是健值对的集合,类似集合
> 2. 可以遍历,方法很多,可以干跟各种数据格式转换

4. WeakMap<br/>
> 1. 直接受对象作为健名（null除外），不接受其他类型的值作为健名
> 2. 健名所指向的对象，不计入垃圾回收机制
> 3. 不能遍历，方法同get,set,has,delete


### 第 3 题：三次握手和四次挥手？

1. 三次握手<br/>
> Client ---------- SEQ J -----------> Server 第一次客户端向服务端发送请求 <br/>
> Client <------ ACK J+1 SEQ I ------- Server 服务端发出回应表示它成功收到了请求 <br/>
> Client ---------- ACK I+1 ---------> Server 客户端发出回应表示它成功收到了服务端的回应 <br/>
> <br/>
> 为了保证服务端能收接受到客户端的信息并能做出正确的应答而进行前两次(第一次和第二次)握手 <br/>
> 为了保证客户端能够接收到服务端的信息并能做出正确的应答而进行后两次(第二次和第三次)握手 <br/>

2. 四次挥手<br/>
> Client ---------- FIN  -----------> Server 客户端告诉服务端它要结束连接了 <br/>
> Client <--------- ACK  ------------ Server 服务端表示它知道连接要结束了, 但是可能还有数据正在传输 <br/>
> Client <--------- FIN  ------------ Server 服务端表示数据传输结束了(此时服务端closed) <br/>
> Client ---------- ACK  -----------> Server 客户端表示收到(发送完ACK后Client进入Time_wait阶段, 等待一会儿后如果没有收到Server的信息则Client关闭) <br/>

3. 为什么连接的时候是三次握手，关闭的时候却是四次握手<br/>
> 因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，"你发的FIN报文我收到了"。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手

4. 为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态
> 虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文

### 第 4 题：['1', '2', '3'].map(parseInt) what & why ?
*[1, NaN, NaN]* <br/>
[['1', '2', '3'].map(parseInt) what & why ?](https://github.com/sisterAn/blog/issues/19)

### 第 5 题：介绍一下BFC及其应用 ?

BFC 就是块级格式上下文，是页面盒模型布局中的一种 CSS 渲染模式，相当于一个独立的容器，里面的元素和外部的元素相互不影响。<br/>

**创建 BFC 的方式有：**
1. html 根元素
2. float 浮动
3. 绝对定位
4. overflow 不为 visiable
5. display 为表格布局或者弹性布局

**BFC 主要的作用是：**
1. 清除浮动
2. 防止同一 BFC 容器中的相邻元素间的外边距重叠问题


### 第 6 题：解释一下IE盒模型和W3C盒模型 ?

盒模型的组成，由里向外content,padding,border,margin.<br/>
在IE盒子模型中，width表示content+padding+border这三个部分的宽度, 举例子这个时候增加border的宽度会压缩content的面积<br/>
在标准的盒子模型中，width指content部分的宽度，举例子这种情况下增加border的宽度会导致整个div占地位置的增加<br/>

> box-sizing:content-box 是W3C盒模型 <br/>
> box-sizing:border-box 是IE盒模型 <br/>
> 默认的是content-box 

### 第 7 题：Cookie Session localStorage 和 sessionStorage ?

#### Cookie
如果不设置过期时间，Cookie会被保存在内存之中，生命周期随浏览器的关闭而结束，这种Cookie被称为会话Cookie<br/>
如果设置了过期时间，Cookie会被保存在电脑的硬盘之中，关闭浏览器之后仍然存在，直到时间结束了才消失<br/>
Cookie是服务端发给客户端的信息，以文本的方式保存在客户端中，每次请求都带上它

#### Session
当程序需要为某个客户端的请求创建一个session时，服务器首先检查这个客户端的请求里是否已包含了一个session标识（称为session id），如果已包含则说明以前已经为此客户端创建过session，服务器就按照session id把这个session检索出来使用（检索不到，会新建一个），如果客户端请求不包含session id，则为客户端创建一个session并且生成一个与此session相关联的session id，session id的值应该是一个既不会重复，又不容易被找到规律以仿造的字符串，这个session id将被在本次响应中返回给客户端保存。保存这个session id的方式可以采用cookie，这样在交互过程中浏览器可以自动的按照规则把这个标识发送给服务器。

#### Cookie和Session的区别
> 1. Cookie保存在浏览器端，Session保存在服务器端
> 2. 单个Cookie保存的数据不能超过4Kb， Session保存的数据大小没有限制
> 3. Cookie以文本的形式只保存字符串的内容，Session中支持任何形式的对象
> 4. Session更加的安全（例如Sessionid存储与Cookie之中，要攻破Session得先攻破Cookie等原因）
> 5. Cookie可以用于：
>     + 记录用户是否登陆过网站
>     + 保存上次登录信息
>     + 浏览计数
>     + 保存上次查看的页面
> 6. Session可以用于:
>     + 网购购物车信息
>     + 用户登录信息
>     + 防止用户非法登录

#### WebStorage
WebStorage和Cookie类似，区别是它是为了更大容量存储设计的，cookie的大小是受限的，并且每次请求一个新的页面的时候cookie都会被发送过去，这样无形中浪费了带宽，另外cookie还需要指定作用域，不可跨域调用<br/>
除此之外，web storage拥有setItem,getItem,removeItem,clear等方法，不像cookie需要前端开发者自己封装setCookie，getCookie 

> 提供一种在cookie之外存储会话数据的路径 <br/>
> 提供一种存储大量可以跨会话存在的数据的机制

HTML5的WebStorage提供了两种API: localStorage(本地存储) 和 sessionStorage(会话存储) <br/>

#### localStorage 和 sessionStorage 的区别
> 1. localStorage 生命周期永久，除非主动删除，不然数据永不消失
> 2. sessionStorage 生命周期仅在当前会话下生效，它引入了一个"浏览器窗口"的概念。sessionStorage是在同源的窗口中始终存在的数据，只要这个浏览器没有关闭，即使刷新或者进入同源的另一个页面，数据仍然存在。但其在关闭浏览器窗口之后就会被销毁。
> 3. 二者存储的大小一般都是5Mb，且一般都保存在浏览器端不与服务器端进行交互
> 4. 二者都只能存储字符串类型
> 5. 不同浏览器无法共享localStorage或sessionStorage中的信息。相同浏览器的不同页面间可以共享相同的 localStorage（页面属于相同域名和端口），但是不同页面或标签页间无法共享sessionStorage的信息。这里需要注意的是，页面及标 签页仅指顶级窗口，如果一个标签页包含多个iframe标签且他们属于同源页面，那么他们之间是可以共享sessionStorage的

#### WebStorage 的优点
> 1. 存储空间更大：cookie为4KB，而WebStorage是5MB
> 2. 节省网络流量：WebStorage不会传送到服务器，存储在本地的数据可以直接获取，也不会像cookie一样每次请求都会传送到服务器，所以减少了客户端和服务器端的交互，节省了网络流量
> 3. 快速显示：有的数据存储在WebStorage上，再加上浏览器本身的缓存。获取数据时可以从本地获取会比从服务器端获取快得多，所以速度更快
> 4. 安全性：WebStorage不会随着HTTP header发送到服务器端，所以安全性相对于cookie来说比较高一些，不会担心截获，但是仍然存在伪造问题
> 5. WebStorage提供了一些方法，数据操作比cookie方便


### 第 8 题：冒泡排序的实现以及改进 ?
冒泡排序的时间复杂度是O(n^2)
```
function bubbleSort(arr) {
    for (let i = 0; i < arr.length; i++) {
        for (let j = 0; j < arr.length - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                const temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
    console.log(arr);
}

// 改进冒泡排序
function bubbleSort1(arr) {
    let i = arr.length - 1;

    while (i > 0) {
        let pos = 0;
        for (let j = 0; j < i; j++) {
            if (arr[j] > arr[j + 1]) {
                pos = j;
                const temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
        i = pos;
    }
    console.log(arr);
}
```
