### 第 61 题: http 1.0 / 1.1 / 2.0

(相关文章)[https://www.jianshu.com/p/52d86558ca57]

**http 1.0**

http1.0 是一个停等协议，每一次请求都建立一个TCP连接，请求完成后立马断开TCP连接。这会导致两个问题： 连接无法复用，队头阻塞

连接无法复用会导致每次请求都经历三次握手和慢启动。三次握手在高延迟的场景下影响较明显，慢启动则对文件类大请求影响较大。

head of line blocking会导致带宽无法被充分利用，以及后续健康请求被阻塞。

**http 1.1**

http1.1优化了性能
1. Persistent connections：用同一个TCP连接传输多个文件
2. Pipeline管道机制：同一个TCP连接中可以发送多个请求
3. 使用了缓存机制进行状态管理
4. 增加了一个connection-header，当connection为close的时候，请求就使用类似于http1.0的短连接，当connection的值为keep-alive时，这个请求结束后仍然保持连接


**http 2.0**

1. 多路复用
2. 二进制分帧
3. 首部压缩
4. 服务端推送


### 第 62 题: Vue 和 React 的区别

1. **Vue 使用的是 web 开发者更熟悉的模板与特性**，Vue的API跟传统web开发者熟悉的模板契合度更高，比如Vue的单文件组件是以模板+JavaScript+CSS的组合模式呈现，它跟web现有的HTML、JavaScript、CSS能够更好地配合。**React 的特色在于函数式编程的理念和丰富的技术选型**。Vue 比起 React 更容易被前端工程师接受，这是一个直观的感受；React 则更容易吸引在 FP 上持续走下去的开发者。

2. Vue提供反应式的数据，当数据改动时，界面就会自动更新，而React里面需要调用方法SetState。

3. 二者都使用了vDOM，而且组件化也是二者非常重要的概念


### 第 63 题: 实现函数的Flatten
```JS
let arr = [1, 2, [3, 4, 5, [6, 7], 8], 9, 10, [11, [12, 13]]]

const flatten = function (arr) {
    while (arr.some(item => Array.isArray(item))) {
        arr = [].concat(...arr)
    }
    return arr
}

console.log(flatten(arr))
```

注意 some 方法会检测数组中的元素是否满足指定条件（函数提供）

some() 方法会依次执行数组的每个元素：
+ 如果有一个元素满足条件，则表达式返回true , 剩余的元素不会再执行检测。
+ 如果没有满足条件的元素，则返回false。


### 第 64 题: 数组的map / reduce / some / filter？

1. map: 通过指定函数处理数组的每一项, 并返回处理后的结果数组 `array.map(function(currentValue,index,arr), thisValue)`
2. reduce: reduce() 方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。reduce() 可以作为一个高阶函数，用于函数的 compose。`array.reduce(function(total, currentValue, currentIndex, arr), initialValue)`
3. filter: 检测数组元素是否满足条件, 并返回满足条件的结果数组`array.filter(function(currentValue,index,arr), thisValue)`


### 第 65 题: 下面代码输出什么?
```JS
var a = 10;
(function () {
    console.log(a)
    a = 5
    console.log(window.a)
    var a = 20;
    console.log(a)
})()
```

依次输出 undefined 10 20.

在立即执行函数中，`var a = 20`; 语句定义了一个局部变量 `a`，由于js的变量声明提升机制，局部变量a的声明会被提升至立即执行函数的函数体最上方，且由于这样的提升并不包括赋值，因此第一条打印语句会打印undefined，最后一条语句会打印20。

由于变量声明提升，`a = 5`; 这条语句执行时，局部的变量a已经声明，因此它产生的效果是对局部的变量a赋值，此时window.a 依旧是最开始赋值的10，



